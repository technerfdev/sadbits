# Task Module Test Guide

## Test Execution Results

### Current Status: FAILING ❌

Both test files are failing with dependency injection errors:
- `task.service.spec.ts` - FAIL
- `task.resolver.spec.ts` - FAIL

---

## Issues Found

### Issue #1: Missing PrismaServices Mock in TaskService Tests
**File:** server/src/task/task.service.spec.ts:8

**Error:**
```
Nest can't resolve dependencies of the TaskService (?).
Please make sure that the argument PrismaServices at index [0] is available in the RootTestModule context.
```

**Root Cause:**
- TaskService depends on PrismaServices (injected via constructor at task.service.ts:37)
- Test module only provides TaskService but not PrismaServices
- PrismaServices is not mocked, so NestJS cannot resolve the dependency

**Solution:**
Mock the PrismaServices dependency in the test. You have two options:

**Option A: Use a Mock Provider (Recommended)**
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { TaskService } from './task.service';

// Create a mock PrismaServices
const mockPrismaService = {
  tasks: {
    create: jest.fn(),
    findUnique: jest.fn(),
    findMany: jest.fn(),
    update: jest.fn(),
  },
};

describe('TaskService', () => {
  let service: TaskService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TaskService,
        {
          provide: 'PrismaServices',
          useValue: mockPrismaService,
        },
      ],
    }).compile();

    service = module.get<TaskService>(TaskService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
```

**Option B: Import PrismaServices and Mock It**
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { TaskService } from './task.service';
import { PrismaServices } from '../../prisma/prisma.service';

describe('TaskService', () => {
  let service: TaskService;
  let prisma: PrismaServices;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TaskService,
        {
          provide: PrismaServices,
          useValue: {
            tasks: {
              create: jest.fn(),
              findUnique: jest.fn(),
              findMany: jest.fn(),
              update: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<TaskService>(TaskService);
    prisma = module.get<PrismaServices>(PrismaServices);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
```

---

### Issue #2: Missing TaskService Mock in TaskResolver Tests
**File:** server/src/task/task.resolver.spec.ts:8

**Error:**
```
Nest can't resolve dependencies of the TaskService (?).
Please make sure that the argument PrismaServices at index [0] is available in the RootTestModule context.
```

**Root Cause:**
- TaskResolver depends on TaskService
- TaskService depends on PrismaServices
- Test provides TaskResolver and TaskService but not PrismaServices
- Since TaskService cannot be instantiated without PrismaServices, the test fails

**Solution:**
Either mock PrismaServices (like Issue #1) OR mock TaskService entirely:

**Option A: Mock TaskService (Recommended for Resolver Tests)**
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { TaskResolver } from './task.resolver';
import { TaskService } from './task.service';

const mockTaskService = {
  create: jest.fn(),
  task: jest.fn(),
  getAll: jest.fn(),
  softDeleteTask: jest.fn(),
  updateTask: jest.fn(),
  getAllDone: jest.fn(),
};

describe('Task Resolver', () => {
  let resolver: TaskResolver;
  let taskService: TaskService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TaskResolver,
        {
          provide: TaskService,
          useValue: mockTaskService,
        },
      ],
    }).compile();

    resolver = module.get<TaskResolver>(TaskResolver);
    taskService = module.get<TaskService>(TaskService);
  });

  it('should be defined', () => {
    expect(resolver).toBeDefined();
  });

  // TODO: Add CRUD tests as indicated by the comment on line 18
});
```

**Option B: Mock PrismaServices (Less Isolated)**
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { TaskResolver } from './task.resolver';
import { TaskService } from './task.service';
import { PrismaServices } from '../../prisma/prisma.service';

describe('Task Resolver', () => {
  let resolver: TaskResolver;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TaskResolver,
        TaskService,
        {
          provide: PrismaServices,
          useValue: {
            tasks: {
              create: jest.fn(),
              findUnique: jest.fn(),
              findMany: jest.fn(),
              update: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    resolver = module.get<TaskResolver>(TaskResolver);
  });

  it('should be defined', () => {
    expect(resolver).toBeDefined();
  });
});
```

---

## Additional Issues to Address

### Issue #3: Missing CRUD Tests
**File:** server/src/task/task.resolver.spec.ts:18

**Note:** Comment indicates "// CURD" (likely meant "CRUD")

**Recommendation:**
Add comprehensive tests for all resolver methods:

```typescript
describe('Task Resolver', () => {
  // ... setup code ...

  describe('createTask', () => {
    it('should create a task', async () => {
      const input = {
        title: 'Test Task',
        description: 'Test Description',
        dueDate: new Date(),
        priority: 1,
        createdBy: 'user-123',
      };

      const expectedTask = {
        id: 'task-123',
        ...input,
        completed: false,
        deletedAt: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      mockTaskService.create.mockResolvedValue(expectedTask);

      const result = await resolver.createTask(input);

      expect(mockTaskService.create).toHaveBeenCalledWith(input);
      expect(result).toEqual(expectedTask);
    });
  });

  describe('task', () => {
    it('should return a single task by id', async () => {
      const taskId = 'task-123';
      const expectedTask = {
        id: taskId,
        title: 'Test Task',
        description: 'Test Description',
        completed: false,
      };

      mockTaskService.task.mockResolvedValue(expectedTask);

      const result = await resolver.task(taskId);

      expect(mockTaskService.task).toHaveBeenCalledWith(taskId);
      expect(result).toEqual(expectedTask);
    });
  });

  describe('tasks', () => {
    it('should return all tasks', async () => {
      const expectedTasks = [
        { id: 'task-1', title: 'Task 1' },
        { id: 'task-2', title: 'Task 2' },
      ];

      mockTaskService.getAll.mockResolvedValue(expectedTasks);

      const result = await resolver.tasks();

      expect(mockTaskService.getAll).toHaveBeenCalled();
      expect(result).toEqual(expectedTasks);
    });
  });

  describe('deleteTask', () => {
    it('should soft delete a task', async () => {
      const taskId = 'task-123';
      const expectedResponse = { success: true };

      mockTaskService.softDeleteTask.mockResolvedValue(expectedResponse);

      const result = await resolver.deleteTask(taskId);

      expect(mockTaskService.softDeleteTask).toHaveBeenCalledWith(taskId);
      expect(result).toEqual(expectedResponse);
    });
  });

  describe('updateTask', () => {
    it('should update a task', async () => {
      const updateInput = {
        id: 'task-123',
        title: 'Updated Title',
        description: 'Updated Description',
        priority: 2,
      };

      const expectedTask = {
        ...updateInput,
        completed: false,
        updatedAt: new Date(),
      };

      mockTaskService.updateTask.mockResolvedValue(expectedTask);

      const result = await resolver.updateTask(updateInput);

      expect(mockTaskService.updateTask).toHaveBeenCalledWith(updateInput);
      expect(result).toEqual(expectedTask);
    });
  });
});
```

---

### Issue #4: Missing Service Tests
**File:** server/src/task/task.service.spec.ts

**Current State:** Only has "should be defined" test

**Recommendation:**
Add tests for all TaskService methods:

```typescript
describe('TaskService', () => {
  let service: TaskService;
  let prisma: any;

  beforeEach(async () => {
    // ... setup with mocked PrismaServices ...
    prisma = module.get(PrismaServices);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create', () => {
    it('should create a task', async () => {
      const input = {
        title: 'Test Task',
        description: 'Test Description',
        dueDate: new Date(),
        priority: 1,
        createdBy: 'user-123',
      };

      const expectedTask = {
        id: 'generated-id',
        title: input.title,
        description: input.description,
        due_date: input.dueDate,
        priority: input.priority,
        author: input.createdBy,
        created_by: input.createdBy,
        created_at: expect.any(Date),
        completed: false,
        deleted_at: null,
        updated_at: null,
      };

      prisma.tasks.create.mockResolvedValue(expectedTask);

      const result = await service.create(input);

      expect(prisma.tasks.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          title: input.title,
          description: input.description,
          due_date: input.dueDate,
          priority: input.priority,
          author: input.createdBy,
          created_by: input.createdBy,
        }),
      });
      expect(result).toEqual(expectedTask);
    });
  });

  describe('task', () => {
    it('should return a task by id', async () => {
      const taskId = 'task-123';
      const expectedTask = {
        id: taskId,
        title: 'Test Task',
        deleted_at: null,
      };

      prisma.tasks.findUnique.mockResolvedValue(expectedTask);

      const result = await service.task(taskId);

      expect(prisma.tasks.findUnique).toHaveBeenCalledWith({
        where: {
          id: taskId,
          deleted_at: { not: null },
        },
      });
      expect(result).toEqual(expectedTask);
    });
  });

  describe('getAll', () => {
    it('should return all non-deleted tasks', async () => {
      const tasks = [
        {
          id: 'task-1',
          title: 'Task 1',
          description: 'Description 1',
          priority: 1,
          due_date: new Date(),
          author: 'user-1',
          created_at: new Date(),
          updated_at: null,
          completed: false,
          deleted_at: null,
        },
      ];

      prisma.tasks.findMany.mockResolvedValue(tasks);

      const result = await service.getAll();

      expect(prisma.tasks.findMany).toHaveBeenCalledWith({
        where: { deleted_at: null },
        orderBy: [{ due_date: 'desc' }, { created_at: 'asc' }],
      });
      expect(result).toHaveLength(1);
    });

    it('should return null when no tasks found', async () => {
      prisma.tasks.findMany.mockResolvedValue([]);

      const result = await service.getAll();

      expect(result).toBeNull();
    });
  });

  describe('softDeleteTask', () => {
    it('should soft delete a task', async () => {
      const taskId = 'task-123';

      prisma.tasks.findUnique.mockResolvedValue({ id: taskId });
      prisma.tasks.update.mockResolvedValue({ id: taskId, deleted_at: new Date() });

      const result = await service.softDeleteTask(taskId);

      expect(result).toEqual({ success: true });
    });

    it('should throw NotFoundException when task not found', async () => {
      const taskId = 'non-existent';

      prisma.tasks.findUnique.mockResolvedValue(null);

      await expect(service.softDeleteTask(taskId)).rejects.toThrow(
        'Task not found'
      );
    });
  });

  describe('updateTask', () => {
    it('should update a task', async () => {
      const updateInput = {
        id: 'task-123',
        title: 'Updated Title',
        description: 'Updated Description',
        priority: 2,
      };

      const existingTask = { id: updateInput.id };
      const updatedTask = {
        ...updateInput,
        updated_at: new Date(),
      };

      prisma.tasks.findUnique.mockResolvedValue(existingTask);
      prisma.tasks.update.mockResolvedValue(updatedTask);

      const result = await service.updateTask(updateInput);

      expect(prisma.tasks.update).toHaveBeenCalled();
      expect(result.title).toBe(updateInput.title);
    });

    it('should throw NotFoundException when task not found', async () => {
      const updateInput = {
        id: 'non-existent',
        title: 'Updated Title',
      };

      prisma.tasks.findUnique.mockResolvedValue(null);

      await expect(service.updateTask(updateInput)).rejects.toThrow(
        'Task not found'
      );
    });
  });
});
```

---

### Issue #5: Potential Bug in task() Method
**File:** server/src/task/task.service.ts:70

**Current Code:**
```typescript
deleted_at: {
  not: null,
},
```

**Problem:**
This filters for tasks where `deleted_at` is NOT null, meaning it returns DELETED tasks only.

**Expected Behavior:**
Should return tasks where `deleted_at` IS null (non-deleted tasks).

**Fix:**
```typescript
task(id: string): Promise<tasks | null> {
  return this.prisma.tasks.findUnique({
    where: {
      id,
      deleted_at: null,  // Changed from { not: null }
    },
  });
}
```

---

## Step-by-Step Resolution Guide

### Step 1: Fix task.service.spec.ts
1. Add PrismaServices mock to the providers array
2. Import necessary dependencies
3. Add comprehensive test cases for all methods
4. Run: `npm test -- src/task/task.service.spec.ts`

### Step 2: Fix task.resolver.spec.ts
1. Add TaskService mock to the providers array
2. Remove PrismaServices dependency (test in isolation)
3. Add CRUD test cases for all resolver methods
4. Run: `npm test -- src/task/task.resolver.spec.ts`

### Step 3: Fix the Bug in task.service.ts
1. Update line 70 to use `deleted_at: null` instead of `deleted_at: { not: null }`
2. Add test case to verify this fix

### Step 4: Run All Tests Together
```bash
npm test -- src/task
```

### Step 5: Verify Coverage (Optional)
```bash
npm run test:cov -- src/task
```

---

## Quick Commands

### Run individual test files:
```bash
npm test -- src/task/task.service.spec.ts
npm test -- src/task/task.resolver.spec.ts
```

### Run all task module tests:
```bash
npm test -- src/task
```

### Run tests in watch mode:
```bash
npm run test:watch -- src/task
```

### Run with coverage:
```bash
npm run test:cov -- src/task
```

---

## Summary

**Total Issues Found:** 5

1. ✗ Missing PrismaServices mock in TaskService tests
2. ✗ Missing dependency mocks in TaskResolver tests
3. ✗ Missing CRUD tests in resolver
4. ✗ Missing comprehensive tests in service
5. ✗ Bug in task() method (returns deleted tasks instead of active ones)

**Expected Result After Fixes:**
- All tests passing ✓
- Comprehensive test coverage for all CRUD operations
- Proper dependency injection mocking
- Bug fixed in task retrieval logic

---

## Notes

- Always mock external dependencies (like PrismaServices) in unit tests
- Use integration tests (e2e) for testing actual database interactions
- Keep resolver tests isolated by mocking the service layer
- Test both happy paths and error cases (like NotFoundException)
- The current tests only check if services/resolvers are defined, which is minimal
